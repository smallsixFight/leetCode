### 通配符匹配（Wildcard Matching）
[原题来源：力扣（LeetCode）](https://leetcode-cn.com/problems/wildcard-matching/)

#### 题目
给定一个字符串 (`s`) 和一个字符模式 (`p`)，实现一个支持`'?'`和`'*'`的通配符匹配。
```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```
两个字符串完全匹配才算匹配成功。

说明：

- `s`可能为空，且只包含从`a-z`的小写字母。
- `p`可能为空，且只包含从`a-z`的小写字母，以及字符 ? 和`*`。

示例 1：
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2：
```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```
示例 3：
```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```
示例 4：
```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```
示例 5：
```
输入:
s = "acdcb"
p = "a*c?b"
输入: false
```

#### 思路
这道题观察几个示例后可以发现，可以使用回溯法来做，即如果当前遍历到的字符如果不匹配，`p`要回溯到前面的`*`的位置的下一位，`s`回溯到一开始匹配到`*`的位置的下一位（让`*`吞掉掉一位），然后继续尝试匹配。

如果`p`串没有回溯的位置，那么就不会成功匹配，直接返回 false；

如果`p`遍历到结尾而`s`还没遍历到尾部，那么`p`也要回溯前一位`*`的位置的下一位再次尝试匹配，因为`*`后面的字符必须匹配成功才是真正的匹配成功。

遍历结束后，如果 p2 不在最后一位，需要判断`p`从 p2 开始后面的字符是否都是`*`，如果存在一个非`*`字符，那么返回 false。

#### 伪代码
```
IS-MATCH(s, p)
    p1, p2 := 0, 0
    backIdx = -1    // 前一个`*`的位置
    sBackIdx = 0    // 前一个匹配到`*`的字符的位置
    while p1 < s.length
        if p2 < p.length && (s[p1] == p[p2] || p[p2] == '?')
            p1 ++
            p2 ++
        elseif p2 < p.length && p[p2] == '*'
            backIdx = p2
            p2 ++
            sBackIdx = p1
        elseif backIdx == -1
            return false
        else
            p1 = sBackIdx +1
            p2 = backIdx +1
    while p2 < p.length
        if p[p2] !='*'
            return false
        p2 ++
    return true
```