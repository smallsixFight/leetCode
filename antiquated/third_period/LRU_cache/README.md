### LRU 缓存机制（LRU Cache）
[原题来源：力扣（LeetCode）](https://leetcode-cn.com/problems/lru-cache/)

#### 题目
运用你所掌握的数据结构，设计和实现一个`LRU (最近最少使用)`缓存机制。它应该支持以下操作：获取数据`get`和写入数据`put`。

获取数据`get(key)`- 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据`put(key, value)`- 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

进阶：  
你是否可以在 **O(1)** 时间复杂度内完成这两种操作？

示例：
```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

#### 思路
先分别把 get() 和 put() 两个方法的流程整理一下。

get() 需要分为 key 存在和不存在两种处理，如果 key 不存在，直接返回 -1；如果 key 存在，有如下三种情况要处理：

- 如果当前节点是最近节点，那么不需要做任何操作；
- 如果当前节点是最远节点，需要将最远节点指针向后移动一个单位，调整下一个结点的 pre，然后将该节点调整为最近节点；
- 如果当前节点是中间节点，需要把调整前后节点的 pre 和 next，然后将该节点调整为最近节点。

put() 需要分为 key 存在和 key 不存在两情况处理，如果 key 存在，更新节点的值，并将节点调整为最近使用的节点；如果 key 不存在，需要分为下面两种情况处理：

- 如果没达到容量上限，创建新节点，并设置为末尾节点；
- 如果达到容量上限，删除最远节点，然后创建新节点，并设置为末尾节点。

这题就不写伪代码了。

#### 题外话
因为以前就研究过 Redis 的 LRU，所以看到题目就反映过来要使用链表+hashMap 来做，不过由于个人对链表的操作是个人的短板，链表的处理连续错了好几次。

#### 伪代码

