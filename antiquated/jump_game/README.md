### 跳跃游戏（Jump Game）
[原题来源：力扣（LeetCode）](https://leetcode-cn.com/problems/jump-game/)

#### 题目
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1：
```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```
示例 2：
```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

#### 思路
第一个想到的思路就是对第一个位置可能跳跃的长度和跳到的位置都进行记录（0 除外），如何下一个元素的值为 0，则直接放弃这个位置；如果记录存在一个位置的最大跳跃长度大于可以超过最后的位置，则直接返回 true；否则继续对记录中的其他位置继续进行跳跃。
如果记录表为空且没能返回 true，则意味着没能达到最后一个位置，返回 false。

上面的思路像 BFS 和 DP，找到子问题的解来获取问题的解。

再对上面的思路和问题进行整理，可以发现，位置上的元素不需要准确的达到最后的位置，只要能超过就可以；另外，当前位置的所有能跳到的位置的下一个位置都包含在当前位置的下一个能跳到最远的位置的子集中，那么则只需要知道下一个能跳到最远位置的位置即可，即贪心思想——在做出一个子选择后，不需要再考虑其他子选择。这样可以减少很多不必要的判断。

下面的伪代码基于贪心思想来写。

#### 伪代码
```
CAN-JUMP(nums) 
    curPoint = 0
    for nums[curPoint] > 0
        if curPoint + nums[curPoint] >= nums.length -1
            return true
        p1 = curPoint
        temp = 0
        for i = nums[p1] to 1
            if i + p1 >= nums.length -1
                return true
            if p1 + i + nums[p1+i] > temp
                temp = p1 + i + nums[p1+i]
                curPoint = p1 +i
    return false
```