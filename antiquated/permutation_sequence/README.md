### 第 k 个排列（Permutation Sequence）
[原题来源：力扣（LeetCode）](https://leetcode-cn.com/problems/spiral-matrix-ii/)

#### 题目
给出集合`[1,2,3,…,n]`，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：  
1. `123`
2. `132`
3. `213`
4. `231`
5. `312`
6. `321`

给定 n 和 k，返回第 k 个排列。

说明：

- 给定 n 的范围是`[1, 9]`。
- 给定 k 的范围是`[1,  n!]`。

示例 1：
```
输入: n = 3, k = 3
输出: "213"
```
示例 2：
```
输入: n = 4, k = 9
输出: "2314"
```

#### 思路一
因为结果集必然是有序的，那么可以先找出目标行的第一个数字，接着把其他数字依序加入数组，之后找到是该数字开头的第几行，然后利用之前做过的那一道寻找下一个排列的方法，找到目标行。

一开始就没对这个思路的效率抱有希望，所以也没写伪代码，代码提交后的结果也确实感人(T^T)，具体代码可以看下`GetPermutation()`。

#### 思路二
思路一其实不是一开始的全部想法，一开始是没打算用全排列的来处理，而是每个数字都迭代来确认。

不过散步的时候因为第一个数字不一定为 1 会不会越界，然后肚子饿导致思维比较散，接着就想着之前做的`下一个排列`，从而走向了使用`下一个排列`的方法来处理的路上。

后面想到可以把记录的数字存起来，下一次迭代的时候如果数字已经被使用，则向后推一位，直到没被使用的数字。

为什么可以这样？因为减去前面的数字位数后，后面数字能够排列的组合必然减少，以及下一个取值的位置必然不会大于 k，那么就不存在越界的情况。

#### 伪代码
```
GET-PERMUTATION-TWO(n, k)
    if n == 1
        return "1"
    record = new Map()
    res = new Array()
    num = 1
    for i = n to 1
        n *= i
    l, min = n, '1'
    for i = 0 to n -1
        num /= l
        val, add = min, (k-1)/num
        for add > 0
            val += 1
            if !record[val]     // 如果数字已被使用，则忽略使用这个数字
                add --
        for record[val]     // 已被使用则顺延下一位
            val += 1
        record[val] = true
        for record[min]     // 设置最小值
            min ++
        res[i] = val
        k -= (k-1)/num *num // 计算在后续组合中所在的行数
        l --
    return res.toString()
```