## 总结

### 简述
本周为做题的第三周，累计刷题 12 题，另失败 1 题，题目如下：

- [下一个更大元素 II](./day_1/next_greater_element_ii)
- [标签验证器](./day_1/tag_validator)
- [函数的独占时间](./day_2/exclusive_time_of_functions)
- [棒球比赛](./day_2/baseball_game)
- [原子的数量](./day_3/number_of_atoms)
- [行星碰撞](./day_3/asteroid_collision)
- [每日温度](./day_4/daily_temperatures)
- [基本计算器 IV](./day_4/basic_calculator_iv)（失败）
- [股票价格跨度](./day_4/online_stock_span)
- [比较含退格的字符串](./day_5/backspace_string_compare)
- [括号的分数](./day_5/score_of_parentheses)
- [索引处的解码字符串](./day_6/decoded_string_at_index)
- [最大频率栈](./day_6/maximum_frequency_stack)

------

### 思路整理

#### 下一个更大元素 II
这题跟上周的 `下一个更大元素 I` 思路上是一样的，只是需要对第一次循环处理后还在栈内的元素再进行一次循环处理，第二次循环不需要再入栈。
在第二次循环处理完毕后，若栈还不为空，则将栈内的元素 pop 并将其对应的记录设置为 -1 即可。

#### 标签验证器
这道题其实按照题目给的条件进行遍历处理就可以了，主要是要考虑各种条件判断，一开始我也连错了几次，就是条件没有考虑完全，在写这里的时候已经补充了注释。

#### 函数的独占时间
我觉得这道题主要的考点就是递归调用函数的处理，例如开启一个函数后，并没有结束它，然后它调用另一个函数，它进行挂起，被调用的函数结束后没有立即执行别的新函数，那么前面挂起的函数其实又开始占用 CPU，需要中间占用的时间也累计起来。
然后还要注意函数重新开始的时间是在上一个函数结束的时间节点的下一个时间结点。

#### 棒球比赛
这道题只是对栈结构的简单应用的题目，根据遍历到的字符进行相应的入栈出栈以及相关的计算操作即可。

#### 原子的数量
这道题的解题思路与前面做过的 `字符串解码` 几乎一模一样，只需要把从左向右遍历改成从右向左遍历，由于原子符号可能是一位或者两位，需要增加处理原子符号的获取，然后需要返回按字典序排序的字符串。这里大致写下处理逻辑：

- 使用两个栈，s1 用来存储需要重复的数字，s2 保存需要进行重复处理的化学式；
- 从右向左遍历，遇到原子或者数字加原子的数字，将连续的出现的原子及其数量组成一个 hashTable 放入 s2；
- 遇到数字加右括号，将数字放入 s1，开辟一个新的 hashTable 来放新的化学式原子计数；
- 遇到左括号时，取出 s1、s2 栈顶两个元素相乘，然后重新放入 s2；
- 最后取出 s2 栈顶元素，按字典序排序生成字符串并返回。

#### 行星碰撞
这道题如果没有示例是比较难理解的，有了示例后，就知道将对行星进行一次二向箔攻击，即如果左侧行星向左移动，右侧行星向右移动，他们也是不会碰撞的。
最后，需要判断遍历到的行星进行碰撞后是否还在，即是否需要入栈。

#### 每日温度
这道题是一个对单调栈的简单应用的一道题目，进行遍历，构建一个单调递减栈，如果遍历到的温度大于栈顶温度，则出栈并记录时间跨度。
遍历完后，若栈不为空，栈内元素全部出栈并将记录设置为 0。

#### 股票价格跨度
这道题是我用来替换 `基本计算器 IV` 的，计算器那道题虽然有思路，但是处理起来极其麻烦，最终选择放弃。
这道题也是对单调栈的应用，不过栈的元素结构变得复杂一些，它的时间跨度不像 `每日温度` 那道题那么算，需要在入栈时同时计算入栈元素的时间跨度值，用于计算后续元素的时间跨度。

#### 比较含退格的字符串
这是一道简单的题目，最简单的方法就是使用两个栈，分别对 `S`、`T` 按照题目要求进行遍历生成栈，然后对比两个栈内元素是否都一致。
因为刚开始做这道题的时候，就闪过从后向前遍历的想法，看到进阶的要求，发现符合，于是就把从后向前遍历的思路完整的做了出来。
从后向前遍历的思路大致就是：因为退格只会退前面的元素，那么从后向前遍历，需要保证遍历到的不可被回退的字符一定要匹配成功；此外，当 `S`、`T` 其中一个遍历完成后，另外一个剩下的字符串一定要能构成一个空字符串，否则就是不匹配。

#### 括号的分数
这道题我是按照之前做 `基本计算器 II` 的思路去做的，只是需要将括号转换成数字和对应的乘法和加法，由于括号的组合只有四种，大致的处理逻辑如下：

- 如果 `S[i]` 为 `(` 时，若下一个为 `)`，s1 放入 1；若下一个为 `(`，s1 放入 2，s2 放入 `*`；
- 如果 `S[i]` 为 `)` 时，按顺序走下面两步进行处理：
    - 若 `S[i-1]` 是 `)`，说明遇到一个需要 `*2` 的操作，那么需要先讲用括号内需要相加的先加起来，然后再 `*2`；
    - 若 `S[i+1]` 是 `(`，说明下一个需要进行相加，s2 加入一个 `+`。

#### 索引处的解码字符串
这道题我一开始直接暴力生成解码后字符串再处理，直接 `out of memory` 了。由于工作和以前做过的题，看到 `重复` 以及 `找某个索引的字符` 想着想着就想到了取模，但是怎么操作还是在看了题解后才知道的。
先解码到字符串长度大于等于 K 的长度，然后往回进行处理判断，逐渐降低字符串长度，根据取模后逐个目标字符的偏移量。

#### 最大频率栈
这道题一开始做的时候，其实已经没有完全遵循栈的结构去处理了，而且虽然在原来的思路考虑降低遍历的次数，其实最终去看代码，会发现并没降低多少。
不过这道题确实让我学习到一种新的思考方式，通过适当的冗余数据实现高效的处理和大大降低运行时对内存的占用。

----- 

### 最后
这周在遇到 `基本计算器 IV` 这道题后过得并不大好，每晚都要抽点时间去想如何处理，但内心其实没多大动力去做这道题，但还是一直坚持。
直到做 `最大频率栈` 这道题时学到新的思考方式，我发现我喜欢这种能学到这种新思路的题目，而不是我已经基本知道要怎么去做，但是处理过程过于复杂还要继续坚持的题目。我现在没能有精力耗费在这上面，这时真的想回去重新上学读书啊。