## 总结

### 简述
本周为刷题的第二周，累计刷题 13 题，题目如下：

- [二叉搜索树迭代器](./day_1/binary_search_three_iterator)
- [基本计算器](./day_1/basic_calculator)
- [用队列实现栈](./day_2/implement_stack_using_queues)
- [基本计算器 II](./day_2/basic_calculator_ii)
- [用栈实现队列](./day_3/implement_queue_using_stacks)
- [去除重复的字母](./day_3/remove_duplicate_letters)
- [验证二叉树的前序序列化](./day_4/verify_preorder_serialization_of_a_binary_tree)
- [扁平化嵌套列表迭代器](./day_4/flatten_nested_list_iterator)
- [迷你语法分析器](./day_4/mini_parser)
- [字符串解码](./day_5/decode_string)
- [移除 K 位数字](./day_5/remove_k_digits)
- [132 模式](./day_6/132_pattern)
- [下一个更大的元素 I](./day_6/next_greater_element_i)

------

### 思路整理

#### 二叉搜索树迭代器
这道题首先要先复习什么叫做 `二叉搜索树`——结点的大小按照 左<根<右 为结构的有序树，根据题目的要求，可以先想到中序遍历，但是中序遍历不符合题目中 `栈` 的要求，由于之前做过中序遍历的迭代实现，也稍微学到了一点异构的思想，那么就把中序遍历异构一下，改成 `右-根-左` 进行遍历入栈即可，最后根据栈来实现题目的 next() 和 hasNext() 函数即可。

但这样并不能达到题目要求的使用 O(h) 的空间来完成，后面通过看题解了解了均摊的使用，由于迭代的遍历是自己实现的栈，那么就可以控制入栈出栈的操作时间段以及位置。均摊实现的思路大致如下：

在构建迭代器的时候进行左子树的左结点的遍历入栈，这样就实现了 O(h) 的时间复杂度。当进行 `next()` 函数的调用时，pop 出栈顶的结点，如果栈顶结点的右结点不为空，表示还有比当前出栈的结点值小的结点，则对这个右结点进行遍历入栈，以此类推。根据二叉树的性质，有右结点需要处理的情况均摊下来就是 O(1)。

#### 基本计算器
我由于之前刚做过 `逆波兰表达式求值`，第一反应就是将算式转换成逆波兰表达式，然后求值。因为这道题的运算符号只有加减号，所以写的逆波兰表达式也不太完整，大致思路如下：

- 使用一个字符串（tokens）和一个栈（stack），tokens 用来存生成的逆波兰表达式，stack 一个用来临时存储符号，然后从左向右遍历；
- 遇到数字时进行内循环获取完整的数字，然后存入 tokens；
- 遇到运算符号时：
    - 如果前一个符号为左括号，可以当作是数字的正负符号，不当作运算符号；
    - 如果 stack 不为空并且栈顶不是左括号，则取出栈顶的元素加入 tokens 中，否则 push 到 stack 中；
- 遇到右括号时，则不断从 stack 中 push 运算符加入 tokens 中，直到遇见左括号。

最后用之前的做过的 `逆波兰表达式求值` 的答案来求值返回就可以了。

第二个思路就是从左向右遍历的同时进行计算，除非遇到左括号，在遇到左括号后，需要先将数字进行保存，然后当遇到右括号时计算括号内的总和，再与之前的总和进行运算获得当前真正的总和，直到遍历结束。

#### 用队列实现栈
一个队列作为输入队列，一个队列作为输出队列，当 push() 时先入队到输入队列，然后将输出队列里的数据依次出队并入队到输入队列，接着交换输入输出队列（即将输入队列作为输出队列，输出队列作为输入队列）。

#### 基本计算器 II
这道题基于与 `基本计算器 I` 思路二一样的思路做的，只是添加 `*`、`/` 的处理。

#### 用栈实现队列
这道题与 `用队列实现栈` 的思路类似，用一个栈作为输入栈，一个栈作为输出栈，当进行出队时，输出栈为空，则将输入栈的内容出栈并入栈到输出栈，再进行出队，peek() 也需要先判断输出栈是否为空，然后执行与前面相同的操作。
由于不是每次 pop() 和 peek() 都会进行栈数据的转移操作，每个入队的元素只会被 push 两次和最多被 pop 两次，所以均摊的时间复杂度是 O(1)。

#### 去除重复的字母
这道题一开始没正确理解到 `字典最小序` 的题意，导致一开始想歪了，还想着跟栈和贪心算法有啥关系。

这道题使用一个链表来保存结果，使用一个 hashTable 保存字符是否存在链表中，使用一个 hashTable 保存每个字符的总个数。

从左向右遍历：
- 当遍历到的字符 `s[i]` 没有在链表中，先从链表链尾向前遍历，如果链尾的字符大于 `s[i]` 且后面还有相同的字符，则将其移出链表，直到链表为空或链尾字符小于 `s[i]` 为止，然后将 `s[i]` 加入链表。
- 当字符 `s[i]` 已存在链表中时，只需要将保存字符个数的 hashTable 的个数减一即可。

由于字符只有小写的 26 个字母，所以可以不使用 tashTable，可以使用两个长度固定为 26 的数组或 slice 代替。

此外，关于为什么使用链表作为描述，因为使用链表不用在最后出栈后反转字符串，而且 golang 的 slice 很好用，干嘛不用。

#### 验证二叉树的前序序列化
这道题先想清楚二叉树的前序序列化后的会满足特定的条件，找出验证时必须满足的条件。前序遍历会先遍历根结点，然后依次遍历左右结点，由于遍历的出现固定，序列化后入栈的顺序也是按照 `根-左-右` 的顺序入栈，只要能够将每个结点进行入栈出栈，遍历结束后栈为空，就表示验证成功。

#### 扁平化嵌套列表迭代器
这道题用递归来处理就可以了，当 `NestedInteger` 是一个整数时，直接入栈，是一个列表时，则递归处理。

#### 迷你语法分析器
受到上一题 `扁平化嵌套列表迭代器` 的影响，一开始只想着用递归来解决，后面发现其实迭代才能友好的解决。大致思路如下：
从左向右遍历，遇到数字时将数字生成一个整数 NestedInteger 放入栈中；遇到左括号时往栈里放入一个 nil；遇到右括号时，说明已经可以生成一个列表，则将栈中数字逐个出栈直到遇到第一个 nil，用出栈的数字创建一个列表 NestedInteger，再放入栈中。遍历结束后，返回栈顶元素（其实这是栈内也就一个元素）。

#### 字符串解码
每对括号内的字符需要先组合好并且重复相同的次数后再与前面的字符进行组合处理，大致处理逻辑如下：

- 分别使用两个栈：s1 用来保存需要重复的字符串的次数，s2 用来保存要组合处理的字符串；
- 从左向右遍历，当遇到字母字符时，将连续的字母字符读作字符串放入 s2；
- 当遇到数字时，将数字放入 s1，跳过数字字符后的左括号字符，然后开辟一个新的空字符串来保存括号内的字母字符串；
- 当遇到右括号时，将 s1、s2 各自出栈一位，将 s2 出栈的字符串重复 s1 出栈的次数后，重新放入 s2。
- 最后返回 s1 栈顶的字符串。

#### 移除 K 位数字
这道题的思路是先思考移除一个数字的情况下使剩下的数字值最小，那么可以发现，只要移除高位中满足 `s[i]>s[i+1]` 这个条件时，移除 `s[i]` 就能达到要求。

另外，当需要移除多位数字时，后续移除的数字依赖于前面的解，那么只要重复这个移除方式直至已经移除 k 个数字或遍历结束。遍历结束后，如果还没移除足够的位数，直接从栈中的直接 pop 剩余需要移除的个数即可（此时栈是单调递增的）。

#### 132 模式

- 从左向右遍历，记录当前位置左侧的最小数字；
- 使用一个单调递减栈来保存可用来进行比较的`a[k]` 数字；
- 从右向左遍历，在 `a[i]` 和 `a[j]` 满足 `13` 模式（当作 `12` 模式来判断就行）的情况下，进行下面的处理：
  - 当栈顶的数字小于等于当前的数字 `a[i]` （即从左到 `j` 为止最小的数字） 时，表示 `a[k]` 无法与之前的数字构成 `132` 模式，可以直接抛弃，依次出栈直到栈为空亦或栈顶元素大于 `a[i]`；
  - 当栈顶的数字小于当前的数字 `a[j]` 时，再将栈顶数字与 `a[i]` 比较，如果大于 `a[i]`，则满足 `132` 模式，可直接返回 true；
  - 最后如果不能返回 true，将 `a[j]` 入栈。
- 关于可以在 `a[i]` 和 `a[j]` 满足 `13` 模式进行处理，不满足的可以忽略的说明：这是由于 `a[i]` 其实是 `a[j]` 左侧最小的数字，如果不满足 `13` 模式，则表示 `a[j] = a[i]`，`a[j]` 与左侧的任何数字不都能构成 `13` 模式，那么也不嫩作为 `a[k]` 的参数，这是由于当前数字从左到当前位置最小的数字，那么也就不能满足 `a[k] > a[i]` 的条件，所以可以忽略跳过。

#### 下一个更大的元素 I
这道题先对 `num2` 遍历，使用一个 hashTable 记录每个数字的下一个更大的数字，并使用一个单调递减栈保存遍历的数字。当遍历到的数字小于栈顶数字时入栈，当遍历到的数字大于栈顶的数字时，表示找到栈顶数字的下一个更大数字，则对栈顶数字进行记录并出栈，然后继续与新的栈顶数字比较执行前面的操作，直到栈顶数字大于遍历到的数字，接着将遍历到的数字入栈。
遍历结束后，若栈不为空，则进行出栈并记录下一个更大的数字为 -1。
最后遍历 `num1`，从 hashTable 获取答案，然后返回。