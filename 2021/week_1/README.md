## 总结

### 简述
本周在周二开始执行计划，所以只有五天。本周累计刷 11 题，题目以栈作为基础的过滤标签，题目如下：

- [有效的括号](./day_1/valid_parentheses)
- [接雨水](./day_1/trapping_rain_water)
- [简化路径](./day_2/simplify_path)
- [柱状图中的最大矩形](./day_2/largest_rectangle_in_histogram)
- [最大矩形](./day_3/maximal_rectangle)
- [二叉树的中序遍历](./day_3/binary_tree_inorder_traversal)
- [二叉树的锯齿形遍历](./day_4/binary_tree_zigzag_level_order_traversal)
- [二叉树的前序遍历](./day_4/binary_tree_preorder_traversal)
- [二叉树的后序遍历](./day_4/binary_tree_postorder_traversal)
- [逆波兰表达式求值](./day_5/evaluate_reverse_polish_notation)
- [最小栈](./day_5/min_stack)

------

### 思路整理
#### 有效的括号
使用基础的栈，遍历遇到左括号就入栈，右括号就 push 栈顶的左括号进行匹配，栈为空或括号不能匹配则直接返回 false，遍历结束后栈为空则返回 true，否则返回 false。
有个不稳定的简化方式，当栈里的元素数量大于未遍历的元素数量，也意味着无法完全匹配，也可直接 return false。

#### 接雨水
这道题我一开始的一个思路是尝试使用双指针遍历累计能接的水的数量，但当在最高的柱子在中间，最高柱子后面雨水累加数量就无法计算正确。
双指针的思路虽不是正确的解法，但发现出现的问题就是最高柱子的位置问题，然后加上有 `动态规划` 这个标签，那么就尝试以最高柱子作为 DP 中的 m 值，将其左右拆分，由于左右两部分的最高柱子分别在尾端和头部，那么分别使用双指针法计算，然后相加即可得到答案。

#### 简化路径
这道题只要顺序遍历，当找到一个简化后的路径后则加到结果集即可。对我来说，这道题考虑的是对几种格式的判断，以前做的时候其实很痛苦，因为我没能很好的理解题目，这次倒是挺快就做出来了。

#### 柱状图中的最大矩形
这道题一开始通过观察想到最爱的柱子具有最大的宽度，那么想着类似 `接雨水` 的处理方式是否可行，虽然觉得可行，但每次以最小柱子作为分割点后，左右两侧又都需要再次寻找最小的柱子，这样一来时间复杂度就上去了，遂放弃。
像装水的木桶一样，能装的水需要向最低的木板看齐；但这道题是平面的，而前面的思路有着最矮的柱子有着最大宽度，那么以每根柱子作为最低的高度，向两边扩展，以遇到更矮的柱子最为边界求面积即可，因为更矮的柱子也会同样去扩展求面积，而更矮的柱子肯定能包含这个比它高的柱子来计算面积的，那么就不会有被忽略的情况出现，于是解法就出来了。

#### 最大矩形
这道题我没能靠自己想出来怎么做，想着动态规划，但却找不到以哪里作为分界点。之后是在看题解里的图以及提到 `柱状图中的最大矩形` 我才恍然大悟，以行为分界点，前 n 行都能构成一个 `柱状图`，所以计算所有能得到的柱状图的最大面积去比较，最后就能得到答案。

### 二叉树的中序遍历
这道题我想着用一个 for 循环进行逐个遍历先将以根结点为起点的左结点先全部入栈，然后通过回溯（pop）再来决定是否取值还是需要遍历左子树。这导致要做额外的判断。
通过看官方的题解，先使用内循环先将当前左子树的左结点入栈，然后取值，然后直接处理右子树，没有右子树则直接取栈顶元素，也就是其父结点，以此类推。

#### 二叉树的锯齿形遍历
这道题我想着最简单的实现方式就是每层都从左到右遍历，使用一个 for 循环获取新的遍历队列，使用一个 for 循环获取值，而值获取的 for 循环也就有两种情况，一种是向前遍历，一种是向后遍历，用数据结构来描述的话就是在队列和栈之间来回切换。
接着就考虑如果只使用栈作为唯一的数据结构，由于栈的先进后出规则，每层遍历后生成的新的遍历栈就会有天生符合题目要求的 Z 方式，但由于子结点可能有两个，那么不能每次都按照左、右结点来入栈，结果前面使用标识来判断向前遍历或是向后遍历取值，那么可以改成通过标识来判断先入左结点，还是先入右结点。

#### 二叉树的前序遍历
这道题我是按照之前中序遍历的做法做的，由于当前结点每次都会先处理掉，所以不用回溯，只有依序把它的右、左结点入栈，每次从栈 push 一个结点循环处理即可。
不过按照前面看了的官方对于中序遍历的解法思路，我也依葫芦画瓢写出了跟官方一样的答案。

#### 二叉树的后序遍历
这道题我一开始使用 hashTable 来记录一个节点的子树是否已经处理，内存占用较高，就直接看了官方的题解，学到一种新的思路，即使用一个指针来指向前一个取值的结点，因为总会先处理左结点，然后处理右结点，最后处理父结点，所以当前一个取值的结点是当前节点的右结点时，意味着右子树已经完全处理好了，那么就可以对当前结点取值并出栈，如果取值结点不是当前结点的右结点，那当前结点要重新入栈，等待右子树处理完成。
二叉树的中序、前序和后序遍历的题解中都提到了 `Morris 遍历`，但没有去学习，后续做补充。
此外，后序遍历题解有个评论用了个变通的方式来解：因为后序是前序的反转，于是这位用前序的处理方式，只是结果集使用 Java 自带的列表，每次都将节点的值放入列表头，以此实现反转。要说答案肯定是对的，但是从解题的角度来讲，我觉得没达到去做这道题的真正意义。

#### 逆波兰表达式求值
这道题没啥难度，我觉得不算中等题，因为题目已经给出测试的表达式必定有效。另外，在总结的时候，我重新看了下题目，发现题目居然连解法的都给出来了。

#### 最小栈
这道题的重点在于要在常数范围内获取到最小值，那么就是需要把最小值存起来，但当 pop 的时候，需要重新遍历得到新的最小值，其实这已经符合题目的要求了。
但 pop 的时间复杂度就不是常数范围了。因为栈的结构是让做题者自定义的，而栈的取值是有序的，那么在 push 时，只要同时将 push 的值与当前最小的值一起存起来就好了，而 push 也还是在常数范围内，pop 只要直接 pop 就好，不用再做额外的操作。
典型的空间换时间。