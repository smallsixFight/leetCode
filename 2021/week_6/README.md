## 总结

### 简述
本周为做题的第四周，累计刷题 13 题，有几道题是重复出现的题，题目如下：

- [用两个栈实现队列](./day_1/yong_liang_ge_zhan_shi_xian_dui_lie_lcof)
- [包含 min 函数的栈](./day_1/bao_han_minhan_shu_de_zhan_lcof)
- [二叉搜索树节点最小距离](./day_1/minimum_distance_between_bst_nodes)
- [队列的最大值](./day_2/dui_lie_de_zui_da_zhi_lcof)
- [栈的最小值](./day_2/min_stack_lcci)
- [化栈为队](./day_2/implement-queue-using-stacks-lcc)
- [布尔运算](./day_3/boolean_evaluation_lcci)
- [直方图的水量](./day_3/volume_of_histogram_lcci)
- [合并区间](./day_4/merge_intervals)
- [插入区间](./day_4/insert_interval)
- [颜色分类](./day_5/sort_colors)
- [对链表进行插入排序](./day_5/insertion_sort_list)
- [删除有序数组中的重复项](./day_5/remove_duplicates_from_sorted_array)

------

### 思路整理

#### 用两个栈实现队列
这道题前面做过，go 用一个 slice 就可以很方便的实现了。

#### 包含 min 函数的栈
这道题前面做过，栈的基本结构处理保存入栈的值，同时保存截至当前入栈元素的最大元素即可。

#### 二叉搜索树节点最小距离
根据二叉搜索树的性质，每个节点的最小差值一定在取左子树的最大值以及右子树的最小值分别与当前节点作比较好取较小值。
所以需要遍历处理每个非叶子结点，分别获取其左子树的最大值和右子树的最小值，然后取与根结点差值较小的值，再与当前的结果比较取较小值作为新的结果。

#### 队列的最大值
这道题咋一看与 `包含 min 函数的栈` 类似，但队列的性质导致不能使用相同的处理方式。

可以使用一个数组和一个单调递减栈来实现。数组按照入队顺序保存的数据，单调递减栈则对入队数据进行排序，维持单调递减。

关于单调递减栈的使用，是由于根据队列的性质，若后续入队的元素为截至当前的最大元素，那么该元素之前的元素不再是最大的元素，并且出队也不会影响 `MaxValue()` 的返回值，因为前面的元素都会先出队。

#### 栈的最小值
这道题是第三次重复了，跟 `包含 min 函数的栈` 是完全一致的题目。

#### 化栈为队
这道题也是以前做过的题目，不过重做起来有些意思。使用两个栈实现队列，那么就使用一个栈作为输入，一个栈作为输出。

这里将使用 s1，s2 分别作为输出和输入栈。元素入队时，先放入 s2，然后 s1 中的元素全部出栈并入栈到 s2 中，然后交换 s1 和 s2 的指针，使 s1 重新作为输出栈，s2 作为输入栈。
出队时，从 s1 取出栈顶元素返回即可。

#### 布尔运算
这道题挺难的，我是看了大佬的解法才勉强做出来的，需要考虑各种括号扩起来的情况进行累计（就算计算结果一样也要累计），这道题容易想到 DP 来处理，但是不同的括号组合就不太好整理。

另，这道题不到跟 `栈` 有什么关系，等一个大佬解法。

#### 直方图的水量
这道题是前面做过的，当时想了好久，所以看到这道题还是很快就回忆起处理思路。

- 先找到直方图中最高的柱子的其中一根，然后将直方图分割为左右两部分；
- 然后分别从左向右以及从右向左（以第一步中找到的柱子作为终点）使用双指针法计算面积；
- 以从左向右遍历为例，双指针法的处理方式如下：
    - 使用 p1，p2 指向 0，1；
    - 若 `nums[p1] > nums[p2]`，计算 `nums[p2]-nums[p1]` 累计到结果 `res` 中，p2++；
    - 若 `nums[p1] <= nums[p2]`，p1 = p2，p2++；
- 从右向左也按照上一步的方式进行处理。
- 最后返回 `res`。

#### 合并区间
先根据 `intervals` 的第一个元素进行排序，相同的话再按照第二个元素进行排序。接着遍历判断是否可合并，不可合并的放入结果集，可合并的修改结果集最后一个数字的范围。

#### 插入区间
使用一个 res 保存结果集，从头开始遍历 按照下面的逻辑处理：

- 若已经执行了插入操作或 `newInterval[0]>intervals[i][1]`，`intervals[i][1]` 直接放入结果集；
- 若 `newInterval[1]<intervals[i][0]`，意味不能合并，直接插入（这里其实隐藏着 `newInterval[1] < intervals[i][0]`）；
- 创建一个新数组，起始位置取 `min(min(newInterval[0], intervals[i][1]), intervals[i][0])`，结束位置取 `max(newInterval[1], intervals[i][1])`，然后使用内存向后遍历尝试合并，直至不能合并为止，最后新数组放入结果集；

#### 颜色分类
根据题意，需要把 `0` 放到数组开头，`2` 放到数组末尾，大致处理逻辑如下：

- 使用 p1、p2 分别指向 `nums` 开头和尾部；
- 从头向尾遍历 `nums`：
    - 若 `nums[i] == 0 && i != p1`，交换 `nums[i]` 和 `nums[p1]` 且 p1 自增加一；
    - 若 `nums[i] == 2`，交换 `nums[i]` 和 `nums[p2]` 且 p2 减一；
    - 其他情况，`i` 自增加一。

#### 对链表进行插入排序
对我来说，这道题的难点还在在于指针的处理。大致的处理逻辑如下：

- 若 `head` 为空结点或之后一个结点，直接返回 `head`；
- 使用一个新结点 `top`，`top.next -> head`，保证遍历结束后不会丢失 `head` 最开始的为止，并且能交换 `head` 与后续结点；
- 使用两个指针 `p1`、`p2` 分别指向 `head`、`head.next`，然后开始遍历比较 `p1`、`p2` 指向的值；
- 若 `p2.Val < p1.Val`，`p1.next` 指向 `p2.next`，从头遍历 `top`，查找适合插入 p2 的位置，插入后要调整对应的 next 指针值；
- 遍历结束后，返回 `top.next`。

#### 删除有序数组中的重复项
根据题意，`nums` 是已经排好序的，那么 `nums` 重复的数字是会连续出现的，那么可以使用双指针法，大致逻辑如下：

- 使用 p1、p2 指向 `nums[0]`，res 作为结果，然后开始遍历；
- 若 `nums[p1] == nums[p2]`，`p2++`；
- 若 `nums[p1] != nums[p2]`，`nums[p1++] = nums[p2]`，`p2++`，`l++`；
- 遍历结束后返回 res。

### 最后
这周把 `栈` 标签的题目基本都做完了，接着开始刷 `排序` 标签的题目了，思路倒真的有些难转过来，看到题目第一反应是把栈用到思路过一遍，看能不能把题目做出来。