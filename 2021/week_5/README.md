## 总结

### 简述
本周为做题的第四周，累计刷题 11 题，失败一题，题目如下：

- [删除字符串中的所有相邻重复项 II](./day_1/remove_all_adjacent_duplicates_in_string_ii)
- [移除无效的括号](./day_1/minimum_remove_to_make_valid_parentheses)
- [设计一个支持增量操作的栈](./day_2/design_a_stack_with_increment_operation)
- [HTML 实体解析器](./day_2/html_entity_parser)
- [用栈操作构建数组](./day_3/build_an_array_with_stack_operations)
- [平衡括号字符串的最少插入次数](./day_3/minimum_insertions_to_balance_a_parentheses_string)
- [整理字符串](./day_4/make_the_string_great)
- [文件夹操作日志搜集器](./day_4/crawler_log_folder)
- [找出最具竞争力的子序列](./day_5/find_the_most_competitive_subsequence)
- [丑数](./day_5/ugly_number)
- [得到连续 K 个 1 的最少相邻交换次数](./day_5/minimum_adjacent_swaps_for_k_consecutive_ones) （失败）

------

### 思路整理

#### 删除字符串中的所有相邻重复项 II
这道题是对组成栈的基本数据结构的小扩展，除了要保存遍历的元素，还要保存连续出现的次数。大致处理逻辑如下：
从左向右遍历，将当前字母和截至当前字母的连续个数放入栈 s 中，如何数量达到 k，则进行移除，否则入栈。最后返回栈内字母组成的字符串。

也许是由于测试案例较少吧，稍微调整下栈的初始化，内存的占用就大大降低了。

#### 移除无效的括号
前面做过类似的题目（过了一周，前面的题目不大记得了），只是由一对左右括号是有效的，改成了一个左括号跟两个右括号是有效的。大致处理逻辑如下：

- 从左向右遍历，将遍历到的字符放入栈 s，并记录左括号的个数；
- 当遍历到左括号或者字母时，直接入栈；
- 当遍历到右括号时，如果左括号个数为 0，不入栈，如果左括号个数大于 0，入栈并且左括号个数减一；
- 遍历结束后，若左括号的个数大于 0，s 中的字符依次出栈放入结果集，如果遇到左括号，则并不放入结果集，直到左括号个数记录变为 0。

#### 设计一个支持增量操作的栈
这道题使用使用一个数组加一个指针就可以实现。这道题感觉不能算中等题。

#### HTML 实体解析器
这道题是以前参加一次竞赛做的题目，然后在使用 hashMap 重做这道题却遇到一个在测试环境和本地能过，提交后不能过的案例，就很奇怪......

#### 用栈操作构建数组
对题目进行解析后，可以发现结果集其实就是一个单调递增栈，使用一个指针 `p` 记录 `target` 中需要比较的数字，然后遍历由 `n` 生成的数组，
当数组中的数字大于等于 `target` 当前的数字，则进行 `push`，否则，就是 `push` 和 `pop` 一起放入结果集。

#### 平衡括号字符串的最少插入次数
这道题跟 `使括号有效的最少添加` 不能说一模一样，只能说很像，由一个左括号与一个右括号进行匹配，变成一个左括号与连续两个右括号进行匹配，大致处理逻辑如下：

- 使用 num1 记录未能匹配的成功的左括号个数，使用 res 作为结果；
- 从左向右遍历，遇到左括号时 num1 自增加一；
- 遇到右括号时，并且是连续的两个右括号：
    - 若 num1 >= 0，num1 减一；
    - 若 num1 == 0，res 加一；
- 遇到单个右括号时：
    - 若 num1 >= 0，num1 减一，res 加一；
    - 若 num1 == 0，res 加 二；
- 遍历结束后，返回 `num1 * 2 + res`。

#### 整理字符串
使用一个栈 `s` 保存结果集，然后从左向右遍历，如果栈为空或者 `s[i]` 与栈顶元素不是大小写字母关系，则将 `s[i]` 放入栈中，否则移除栈顶元素。最后返回栈 `s` 内元素组成的字符串。

#### 文件夹操作日志搜集器
使用一个栈 `s` 作记录，从左向右遍历，处理逻辑如下：

- 遇到 `x/` 时，放入栈 `s` 中；
- 遇到 `../` 时，取出栈顶元素，栈为空则跳过；
- 遇到 `./` 时，跳过。

#### 找出最具竞争力的子序列
这道题可以使用一个另类的单调栈来做，这个单调栈近似于一个单调递增栈，因为新的元素除了要比栈顶元素小，还需要后续的长度加上栈内元素的长度需要满足 `k` 的要求。大致处理逻辑如下：

- 使用一个栈 `s` 保存结果集，从左向右遍历 nums；
- 若栈为空或 `nums[i]` 大于等于栈顶元素且栈的大小 < k，则 `nums[i]` 入栈，否则跳过；
- 若 `nums[i]` 比栈顶元素小，判断 `nums[i]` 开始后续的元素数量能否把栈填充到 `k`，可以则移除栈顶元素，重复前面的步骤；直到栈为空，或不能达到 `k` 值，或大于等于栈顶元素，将 `nums[i]` 入栈。
- 遍历结束后，返回栈 `s` 内元素生成的字符串。

#### 丑数
这道题是 leetCode 的每日一题，大致思路如下：
如果是 2/3/5 的倍数，则作相应的除法，如果除之后结果值为 1，则返回 true，如果不是 2/3/5 的倍数，直接返回 false。

#### 得到连续 K 个 1 的最少相邻交换次数
这道题作为困难题，难在了数学上。需要对暴力法进行优化，没能做出来。以后再进行尝试吧。

### 最后
休息一周看看书状态恢复得不错，不过以后遇到困难题还是量力而行吧。