### 简述
本周为做题的第九周（实为第八周），累计刷题 15 题，题目如下：

- [员工的重要性](./day_1/employee_importance)
- [电话号码的字母组合](./day_1/letter_combinations_of_a_phone_number)
- [相同的树](./day_2/same_tree)
- [验证二叉搜索树](./day_2/validate_binary_search_tree)
- [删除并获得点数](./day_3/delete_and_earn)
- [二叉树的最大深度](./day_3/maximum_depth_of_binary_tree)
- [对称二叉树](./day_3/symmetric_tree)
- [从前序与中序遍历序列构造二叉树](./day_4/construct_binary_tree_from_preorder_and_inorder_traversal)
- [解码异或后的数组](./day_4/decode_xored_array)
- [从中序与后序遍历序列构造二叉树](./day_5/construct_binary_tree_from_inorder_and_postorder_traversal)
- [将有序数组转换为二叉搜索树](./day_5/convert_sorted_array_to_binary_search_tree)
- [有序链表转换二叉搜索树](./day_5/convert_sorted_list_to_binary_search_tree)
- [数组异或操作](./day_5/xor_operation_in_an_array)
- [平衡二叉树](./day_6/balanced_binary_tree)
- [二叉树的最小深度](./day_6/minimum_depth_of_binary_tree)

------

### 思路整理

#### 员工的重要性
这道题先分别将不同员工的重要性和直接下属生成对应的映射记录，然后根据给定的员工 id，累计他的直接下属员工的重要性值，并将其直接下属员工放到队列中。以此类推，直到队列为空，返回累计值。

#### 电话号码的字母组合
这道题我倾向于用 BFS，而不是题目标签的 DFS，这样就不用进行回溯了。

这道题先将数字生成对应的字典映射表，然后遍历 `digits`，每次生成一个新的组合放入队列，遍历结束后，返回队列中剩下的内容即可。

#### 相同的树
这道题可以用递归来维护一个天然的栈，以此来实现 DFS 处理，先比较当前结点，然后递归处理左子树和右子树。

#### 验证二叉搜索树
这道题的考点在于当前需要跟整个左子树和右子树的所有结点进行比较对比，而不是单纯跟子结点比较就好（踩坑的我），所以我一开始通过返回子树的最大值和最小值进行比较判断。

后面通过题解，学到利用中序遍历的顺序来进行判断，那就不用进行编写返回值了。

#### 删除并获得点数
这道题是 leetCode 每日一题，根据 `动态规划` 的标签，就往这个方向去思考。先排序，然后将相同的数作汇总，然后以数字差大于 `1` 的作为分割点，处理前面不同数字的累计值，获取最大值。

我一开始的处理方式就跟题解的第二个方式一样，先排序，把相同的数字看作一个整体，不过如何切割的临界点是从题解学来的。

#### 二叉树的最大深度
这道题用 DFS 的话用递归很容易实现，每次只要返回当前结点的子树的最大深度加一即可。

通过 BFS 的话，可以很简单的实现循环的处理方式，进行层次遍历，将所有不为空的子结点放入队列中，每遍历一层深度加一，遍历结束直接返回即可。

#### 对称二叉树
这道题跟 `相同的树` 这道题很类似，只要交换对比的左右子树结点即可。

#### 从前序与中序遍历序列构造二叉树
根据前序遍历和中序遍历的规律，可以知道，前序遍历的第一个元素为根节点，且后续分别为其左子树的所有结点和右子树所有结点两部分；
而中序遍历的得到的数组中，根节点前面的元素为其左子树结点，后面的元素为右子树结点。那么可以通过递归来拆分构建二叉树。

#### 解码异或后的数组
这道题是每日一题的题目，只是简单的异或运算处理。

#### 从中序与后序遍历序列构造二叉树
通过中序遍历和后序遍历的特性，可以知道，后序遍历的数组最后一位是根结点，而中序遍历中该元素左侧均为根节点左侧元素，且后序遍历数组中从头遍历的相同个数的结点也是左子树的结点。

#### 将有序数组转换为二叉搜索树
先找到中位数作为根节点，然后将其左侧和右侧拆分为两个子数组，继续找中位数作为子树的根节点，以此类推。

#### 数组异或操作
这道题是每日一题的题目，也只是简单的异或运算处理。

#### 平衡二叉树
深度遍历分别获取左子树和右子树的高度，由于子树不平衡，当前树肯定也不平衡，所以可以将子树递归处理分为三类，第一是当前结点是 nil，直接返回 0，第二当前结点为叶子结点，返回 1，第三就是递归处理子树，获取返回值，如果子树其中之一返回 -1，则直接返回 -1，否则判断两个子树的高度差，大于 1 则直接返回 -1，否则返回左右子树中最高高度加一。

#### 二叉树的最小深度
这道用 BFS 来处理，当遇到第一个子结点都为 nil 时，直接返回当前遍历到的层数（即高度）。

------

### 最后
这周选的是 `深度优先探索` 的题目来做，所以挺多是之前做过的，不过对比了以前做题的思路，发现有的能想出比以前好很多的写法，有的反而想出了昏招，真是奇奇怪怪。

#### 碎碎念
哎，周一一开始脑子就有点瓦特，有人问我 linux 的命令熟不熟悉，我竟然好几秒没反映过来 linux 这个词是啥。