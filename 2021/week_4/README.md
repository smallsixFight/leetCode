## 总结

### 简述
本周为做题的第四周，累计刷题 12 题，题目如下：

- [子数组的最小值之和](./day_1/sum_of_subarray_minimums)
- [使括号有效的最少添加](./day_1/minimum_add_to_make_parentheses_valid)
- [验证栈序列](./day_2/validate_stack_sequences)
- [奇偶跳](./day_2/odd_even_jump)
- [检查替换后的词是否有效](./day_3/check_if_word_is_valid_after_substitutions)
- [链表中的下一个更大节点](./day_3/next_greater_node_in_linked_list)
- [删除最外层的括号](./day_4/remove_outermost_parentheses)
- [删除字符串中的所有相邻重复项](./day_4/remove_all_adjacent_duplicates_in_string)
- [不同字符的最小子序列](./day_5/smallest_subsequence_of_distinct_characters)
- [表现良好的最长时间段](./day_5/longest_well_performing_interval)
- [叶值的最小代价生成树](./day_6/minimum_cost_tree_from_leaf_values)
- [反转每对括号间的子串](./day_6/reverse_substrings_between_each_pair_of_parentheses)

------

### 思路整理

#### 子数组的最小值之和
这道题稍微思考后可以联想到之前做的 `柱状图中的最大矩形`，但这道题是 `柱状图中的最大矩形` 的扩展，因为这道题需要的求和，按照做 `柱状图中的最大矩形` 的思路直接去做，就会变成暴力解法了，会重复很多次相同的比较计算，那么就要去找到避免重复的处理方式。
这道题不用每次都去内循环左右遍历扩展找边界，可以先把数组中每个元素的边界前找出来。然后通过一开始的暴力解法可以发现一个最大面积的公式 `(i-left+1) + (right-i) + (i-left) * (right-i) => (i-left+1) * (right-i+1)`，这样就可以遍历处理了。

#### 使括号有效的最少添加
这道题感觉应该属于 `简单` 难度的题目才对，从左向右遍历，分别记录可以用于跟右括号抵消的左括号数和需要补充的左括号数量即可，最后返回两数之和。

#### 验证栈序列
使用一个栈用来保存遍历 `pushed` 时未能处理的元素。遍历 `pushed`，如果遍历到的元素与 `popped` 当前可出栈的元素相同，则将 `popped` 的指针也向后移动一位，比较下一位；不相同时则将 `pushed` 当前的元素放入自定义栈中。
遍历结束后，若栈不为空，进行 pop 与 `popped` 当前需要出栈的元素比较，相同则继续 pop 比较，不同则直接返回 false，栈为空时返回 true。

#### 奇偶跳
这道题很明显就是要先找到每个位置进行奇偶跳能到达的位置，但如何处理获得是最费思量的。暴力法最简单，但肯定过不了。
这道题的处理思路大致就是，先对数组的每个元素进行排序来获取对应的索引序列（分别从大到小和从小到大），来分别获取对应奇跳数组和偶跳数组，最后对数组的每个元素进行奇偶跳然后记录即可。

#### 检查替换后的词是否有效
这道题最重要的就是要逆向想一下，题目以及示例都是填充 abc，但是验证嘛，那就抽出 `abc`，如果不能抽出 `abc`，或者遍历完后还有不能组合成 `abc` 字符串抽出的，直接返回 false。

#### 链表中的下一个更大节点
这道题目与 `下一个更大元素 I` 类似，只是将数组改成了链表，但其实做法基本上一模一样，可以用一个单调栈来处理。另外，由于链表没有索引，所以栈结构需要记录当前遍历到的结点在结果集中的位置。

#### 删除最外层的括号
这道题主要需要理解题目的意思，理解到了就容易做了：当首次遇到两个连续的左括号时，从第二个括号开始直到遇见跟第一个左括号匹配的右括号中间的内容都是原语，都是结果集的一员。

#### 删除字符串中的所有相邻重复项
这道题是一个简单的栈应用题目，从左向右遍历，如果遍历到的元素与栈顶元素相同，栈进行 pop，然后跳过该元素，否则元素入栈。遍历处理结束后，返回栈内元素组成的字符串。

#### 不同字符的最小子序列
这道题跟 `去除重复的字母` 是一模一样的，这里就当作重新复习整理思路再做一遍。大致思路如下：

- 先进行一次遍历，记录每个字符重复出现的次数；
- 接着进行第二次遍历，使用一个栈 s 作为结果集和一个 hashTable 记录已经在结果集中的字符，从左向右，进行如下处理：
    - 如果当前字符还未在 s 中，并且字典序小于 s 栈顶的字符，并且栈顶的字符在后续遍历的字符中还会出现，则 pop，并设置 hashTable 为true；
    - 继续执行前一个步骤，直到栈为空 or 栈顶元素字典序小于当前字符 or 栈顶字符在后续不再出现;
    - 内循环遍历结束后，将字符入栈，并在 hashTable 记录为 true；
    - 如果字符已存在，则将次数记录减一。

#### 表现良好的最长时间段
这道题先将 `hours` 中的时间划分为疲劳和非疲劳，用 `1` 和 `-1` 代替，那么就是需要找到和大于 `0` 的最大连续子数组。暴力解法就是先前 n 天的和，然后两两相减，找到符合条件的最长子数组。
暴力解法存在很多无用的判断计算，例如当前 n 天的连续和是最大值时，那么这个子数组就有很大几率是结果，应进行最少次的判断处理，那么可以生成一个单调递减栈，然后再进行处理。

#### 叶值的最小代价生成树
这道题没做出来，一直被树的结构束缚着，怕生成一棵不是树的结果，最后是看了题解才做了出来，也想通了 DP 的处理方式。

#### 反转每对括号间的子串
这道题跟之前做的一些题有着类似的思路，好像是计算器那些类型的题目，所以做起来挺快的，大致思路如下：

- 从左向右遍历，遇到 `(` 则使用一个新的数组保存后续连续的字符串；
- 遇到 `)` 则将栈顶字符串 pop 反转后跟新的栈顶字符串组合在一起；
- 遇到字符则内循环将连续的字符组成一个字符串保存到栈顶；
- 遍历结束后，将栈内的字符串组合成一个新的字符串返回。

----

### 最后
- 中等类型也有上限挺高的题目。
- 以及相同套路的题目相对容易做很多。
- 对树结构的处理很不熟练。
- 对单调栈的应用不熟练。

休息一周，然后继续。